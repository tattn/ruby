$nop

// ===============================================
// deal with variables
// ===============================================
$getlocal {
/*
    int i, lev = (int)level;
    VALUE *ep = GET_EP();

    for (i = 0; i < lev; i++) {
	ep = GET_PREV_EP(ep);
    }
    val = *(ep - idx);
*/
    int i, lev = (int)level;
    VALUE *ep = GET_EP();
	VALUE idx = insn->pc[1];

    for (i = 0; i < lev; i++) {
	ep = GET_PREV_EP(ep);
    }
	_val = BUILDER->CreateLoad(PV(ep - idx));
}

$getlocal_OP__WC__0 {
	Value *ep = _GET_EP();

	Value *idx_ep = BUILDER->CreateInBoundsGEP(ep, BUILDER->CreateSub(RB_JIT->values->valueZero, _idx));
	_val = BUILDER->CreateLoad(idx_ep);
}

$getlocal_OP__WC__1 {
    VALUE *ep = GET_EP();
	ep = GET_PREV_EP(ep);
	Value *_ep = BUILDER->CreateIntToPtr(RB_JIT->values->value((VALUE)ep), RB_JIT->types->pvalueT);
	Value *idx_ep = BUILDER->CreateInBoundsGEP(_ep, BUILDER->CreateSub(RB_JIT->values->valueZero, _idx));
	_val = BUILDER->CreateLoad(idx_ep);
}

// $setlocal {
// /*
//     int i, lev = (int)level;
//     VALUE *ep = GET_EP();
//
//     for (i = 0; i < lev; i++) {
// 	ep = GET_PREV_EP(ep);
//     }
//     *(ep - idx) = val;
// */
// }

$setlocal_OP__WC__0 {
	Value *ep = _GET_EP();

	Value *idx_ep = BUILDER->CreateInBoundsGEP(ep, BUILDER->CreateSub(RB_JIT->values->valueZero, _idx));
	BUILDER->CreateStore(_val, idx_ep);
}

$setlocal_OP__WC__1 {
	VALUE *ep = GET_EP();
	ep = GET_PREV_EP(ep);
	Value *_ep = BUILDER->CreateIntToPtr(RB_JIT->values->value((VALUE)ep), RB_JIT->types->pvalueT);
	Value *idx_ep = BUILDER->CreateInBoundsGEP(_ep, BUILDER->CreateSub(RB_JIT->values->valueZero, _idx));
	BUILDER->CreateStore(_val, idx_ep);
}

$getspecial {
    // val = vm_getspecial(th, GET_LEP(), key, type);
	Value *ep = BUILDER->CreateCall(RB_JIT->funcs->VM_EP_LEP, _GET_EP());
	_val = BUILDER->CreateCall4(RB_JIT->funcs->vm_getspecial, _GET_TH(), ep, V(key), V(type));
}

// $setspecial

$getinstancevariable {
    // val = vm_getinstancevariable(GET_SELF(), id, ic);
	_val = BUILDER->CreateCall3(RB_JIT->funcs->vm_getinstancevariable, GET_SELF(), V(id), PV(ic));
}

$setinstancevariable {
    // vm_setinstancevariable(GET_SELF(), id, val, ic);
	BUILDER->CreateCall4(RB_JIT->funcs->vm_setinstancevariable, GET_SELF(), V(id), _val, PV(ic));
}

$getclassvariable {
    // val = rb_cvar_get(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id);
	Value *a = BUILDER->CreateCall(RB_JIT->funcs->rb_vm_get_cref, _GET_EP());
	Value *b = BUILDER->CreateCall2(RB_JIT->funcs->vm_get_cvar_base, a, _GET_CFP());
	_val = BUILDER->CreateCall2(RB_JIT->funcs->rb_cvar_get, b, V(id));
}

$setclassvariable {
    // rb_cvar_set(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id, val);
	Value *a = BUILDER->CreateCall(RB_JIT->funcs->rb_vm_get_cref, _GET_EP());
	Value *b = BUILDER->CreateCall2(RB_JIT->funcs->vm_get_cvar_base, a, _GET_CFP());
	BUILDER->CreateCall3(RB_JIT->funcs->rb_cvar_set, b, V(id), _val);
}

$getconstant {
    // val = vm_get_ev_const(th, klass, id, 0);
	_val = BUILDER->CreateCall4(RB_JIT->funcs->vm_get_ev_const, _GET_TH(), _klass, V(id), I(0));
}

$setconstant {
    // vm_check_if_namespace(cbase);
    // rb_const_set(cbase, id, val);
	BUILDER->CreateCall(RB_JIT->funcs->vm_check_if_namespace, _cbase);
	BUILDER->CreateCall3(RB_JIT->funcs->rb_const_set, _cbase, V(id), _val);
}

$getglobal {
    // val = GET_GLOBAL((VALUE)entry);
	_val = BUILDER->CreateCall(RB_JIT->funcs->rb_gvar_get, _entry);
}

$setglobal {
    // SET_GLOBAL((VALUE)entry, val);
	BUILDER->CreateCall2(RB_JIT->funcs->rb_gvar_set, _entry, _val);
}


// ===============================================
// deal with values
// ===============================================

$putnil {
	_val = RB_JIT->values->value(Qnil);
}

$putself {
	_val = GET_SELF();
}

$putobject
$putobject_OP_INT2FIX_O_0_C_
$putobject_OP_INT2FIX_O_1_C_

$putspecialobject {
    enum vm_special_object_type type = (enum vm_special_object_type)value_type;

    switch (type) {
      case VM_SPECIAL_OBJECT_VMCORE:
	_val = V(rb_mRubyVMFrozenCore);
	break;
      case VM_SPECIAL_OBJECT_CBASE:
	_val = _FCALL1(vm_get_cbase, _GET_EP());
	break;
      case VM_SPECIAL_OBJECT_CONST_BASE:
	_val = _FCALL1(vm_get_const_base, _GET_EP());
	break;
      default:
	rb_bug("putspecialobject insn: unknown value_type");
    }
}

$putiseq {
    // ret = iseq->self;
	_ret = jit_values->value(iseq->self);
}

$putstring {
    // val = rb_str_resurrect(str);
	_val = BUILDER->CreateCall(RB_JIT->funcs->rb_str_resurrect, _str);
}

$concatstrings {
    // rb_num_t i = num - 1;
    //
    // val = rb_str_resurrect(TOPN(i));
    // while (i-- > 0) {
	// const VALUE v = TOPN(i);
	// rb_str_append(val, v);
    // }
    // POPN(num);

    rb_num_t i = num - 1;
	_val = BUILDER->CreateCall(RB_JIT->funcs->rb_str_resurrect, _TOPN(i));
	while (i-- > 0) {
		BUILDER->CreateCall2(RB_JIT->funcs->rb_str_append, _val, _TOPN(i));
	}
	_POPN(num);
}

$tostring {
    // val = rb_obj_as_string(val);
	_val = BUILDER->CreateCall(RB_JIT->funcs->rb_obj_as_string, _val);
}

// $toregexp

$newarray {
    // val = rb_ary_new4((long)num, STACK_ADDR_FROM_TOP(num));
    // POPN(num);
	_val = BUILDER->CreateCall2(RB_JIT->funcs->rb_ary_new_from_values, V(num), _STACK_ADDR_FROM_TOP(num));
	_POPN(num);
}

$duparray {
    // val = rb_ary_resurrect(ary);
	_val = BUILDER->CreateCall(RB_JIT->funcs->rb_ary_resurrect, _ary);
}

$expandarray {
    // vm_expandarray(GET_CFP(), ary, num, (int)flag);
	BUILDER->CreateCall3(RB_JIT->funcs->vm_expandarray, _ary, V(num), V(flag));
}

// $concatarray

// $splatarray

// $newhash

$newrange {
    // val = rb_range_new(low, high, (int)flag);
	BUILDER->CreateCall3(RB_JIT->funcs->rb_range_new, _low, _high, V(flag));
}

// ===============================================
// stack operations
// ===============================================

$pop {
}

$dup {
    _val1 = _val2 = _val;
}

$dupn {
    // rb_num_t i;
    // VALUE *sp = STACK_ADDR_FROM_TOP(n);
    // for (i = 0; i < n; i++) {
	// GET_SP()[i] = sp[i];
    // }
    // INC_SP(n);
    rb_num_t i;
    Value *sp_ptr = _STACK_ADDR_FROM_TOP(n);
    for (i = 0; i < n; i++) {
		Value *orig_sp_ptr = BUILDER->CreateInBoundsGEP(sp_ptr, jit_values->intV(i));
		Value *orig_sp = BUILDER->CreateLoad(orig_sp_ptr);
		Value *dest_sp = _NEXT_SP_PTR(i);
		BUILDER->CreateStore(orig_sp, dest_sp);
    }
    _INC_SP(n);
}


$swap

// $reverse

$reput

$topn {
    _val = _TOPN(n);
}

$setn {
    // TOPN(n-1) = val;
	SET_TOPN(n+1, _val); // ここ不安
}

$adjuststack {
    // DEC_SP(n);
	_POPN(n);
}

// ===============================================
// deal with setting
// ===============================================

$defined {
    // val = vm_defined(th, GET_CFP(), op_type, obj, needstr, v);
	_val = BUILDER->CreateCall(RB_JIT->funcs->vm_defined, { _GET_TH(), _GET_CFP(), V(op_type), _obj, _needstr, _v });
}

//$checkmatch

//$checkkeyword

$trace { // 未実装
}

// ===============================================
// deal with control flow 1: class/module
// ===============================================

//$defineclass

$send {
	Value *_ci = PT(ci, rb_call_info_t);
	ci->argc = ci->orig_argc;
	Value *ci_orig_argc_elmptr = BUILDER->CreateStructGEP(_ci, 2);
	Value *ci_orig_argc = BUILDER->CreateLoad(ci_orig_argc_elmptr);
	Value *ci_argc_elmptr = BUILDER->CreateStructGEP(_ci, 12);
	BUILDER->CreateStore(ci_orig_argc, ci_argc_elmptr);

	BUILDER->CreateCall4(RB_JIT->funcs->vm_caller_setup_arg_block, _GET_TH(), _GET_CFP(), _ci, RB_JIT->values->int32Zero);

	Value *ci_recv_elmptr = BUILDER->CreateStructGEP(_ci, 11);
	Value *ci_recv = _TOPN(ci->argc);
	BUILDER->CreateStore(ci_recv, ci_recv_elmptr);
	BUILDER->CreateCall2(RB_JIT->funcs->vm_search_method, _ci, ci_recv);

	Value *ci_call_elmptr = BUILDER->CreateStructGEP(_ci, 14);
	Value *ci_call = BUILDER->CreateLoad(ci_call_elmptr);
	_CALL_METHOD(_ci);
}

$opt_str_freeze {
    if (BASIC_OP_UNREDEFINED_P(BOP_FREEZE, STRING_REDEFINED_OP_FLAG)) {
	_val = _str;
    }
    else {
	//val = rb_funcall(rb_str_resurrect(str), idFreeze, 0);
	Value *tmp = BUILDER->CreateCall(RB_JIT->funcs->rb_str_resurrect, _str);
	_val = BUILDER->CreateCall3(RB_JIT->funcs->rb_funcall, tmp, I(idFreeze), I(0));
    }
}

$opt_send_without_block {
	Value *_ci = PT(ci, rb_call_info_t);
	ci->argc = ci->orig_argc;
	Value *ci_recv_elmptr = BUILDER->CreateStructGEP(_ci, 11);
	Value *ci_recv = _TOPN(ci->argc);
	BUILDER->CreateStore(ci_recv, ci_recv_elmptr);
	BUILDER->CreateCall2(RB_JIT->funcs->vm_search_method, _ci, ci_recv);
	Value *ci_call_elmptr = BUILDER->CreateStructGEP(_ci, 14);
	Value *ci_call = BUILDER->CreateLoad(ci_call_elmptr);
	_CALL_METHOD(_ci);
}

//$invokesuper

//$invokeblock

$leave { // 途中
	BUILDER->CreateCall(RB_JIT->funcs->vm_pop_frame, _GET_TH());
	if (UNLIKELY(VM_FRAME_TYPE_FINISH_P(GET_CFP()))) {
		jit_codegen_make_return(codegen_func, _val);
	}
	else {
		_RESTORE_REGS();
		_PUSH(_val);
		jit_codegen_make_return(codegen_func);
	}

}

// ===============================================
// deal with control flow 3: exception
// ===============================================

$throw { // 未試行
    // RUBY_VM_CHECK_INTS(th);
    // val = vm_throw(th, GET_CFP(), throw_state, throwobj);
    // THROW_EXCEPTION(val);
	_val = BUILDER->CreateCall4(RB_JIT->funcs->vm_throw, _GET_TH(), _GET_CFP(), V(throw_state), _throwobj);
	jit_codegen_make_return(codegen_func, _val);
}

// ===============================================
// deal with control flow 4: local jump
// ===============================================

$jump { // JUMP(dst);
	if (dst < 0) {
	}
	// 条件分岐の結果 jump にたどり着いて、トレース範囲外までジャンプするパターンに対応する

	jit_insn_t *next_insn = insns[insn->index + 1];
	jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, next_insn, dst);
	if (!dest_insn) {
		JIT_DEBUG_LOG("dest_insn_else");
		Value* cfp_pc_ptr = BUILDER->CreateStructGEP(_GET_CFP(), 0);
		Value* cfp_pc = BUILDER->CreateLoad(cfp_pc_ptr);
		/* Value* tmp = BUILDER->CreateInBoundsGEP(cfp_pc, V(dst)); */
		/* PRINT_VAL(tmp); */
		/* tmp = BUILDER->CreateLoad(tmp); */
		/* PRINT_VAL(tmp); */
		/* Value* tmp2 = BUILDER->CreateAdd(tmp, V(dst)); */

		// jit.cpp:484で強制的にPCを加算しているので、フラグ等で調整したほうがいいかも
		auto last_insn = trace->insns[trace->insns_iterator - 1];
		VALUE *first_pc = trace->insns[0]->pc;
		/* Value *next_cfp_pc = PV(insn->pc + insn->len + dst); */
		Value *next_cfp_pc = PV(insn->pc + insn->len + dst - (last_insn->pc - first_pc + last_insn->len));
		/* BUILDER->CreateStore(tmp, cfp_pc_ptr); */
		BUILDER->CreateStore(next_cfp_pc, cfp_pc_ptr);
		jit_codegen_make_return(codegen_func);
	}
	else {
		BUILDER->CreateBr(dest_insn->bb);
	}


	// jit_insn_t *next_insn = insns[insn->index + 1];
	// jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, next_insn, dst);
	// BasicBlock *bb_dst;
	// if (dest_insn) {
	// 	bb_dst = dest_insn->bb;
	// }
	// else {
	// 	JIT_DEBUG_LOG("dest_insn_else");
	// 	bb_dst = CreateBasicBlock("jump");
	// 	SetBasicBlock(bb_dst);
	// 	Value* cfp_pc = BUILDER->CreateStructGEP(_GET_CFP(), 0);
	// 	Value* tmp = BUILDER->CreateInBoundsGEP(cfp_pc, V(dst));
	// 	tmp = BUILDER->CreateLoad(tmp);
	// 	//Value* tmp2 = BUILDER->CreateAdd(tmp, RB_JIT->values->value(dst));
	// 	PRINT_VAL(tmp);
	// 	BUILDER->CreateStore(tmp, cfp_pc);
	// 	jit_codegen_make_return(codegen_func);
	// 	SetBasicBlock(insn->bb);
	// }
	// BUILDER->CreateBr(bb_dst);
}

$branchif {
	/* Value *test = _RTEST(val); */
	/* BasicBlock *bb_dst; */
    /*  */
	/* if (dst < 0) { */
	/* 	//jit_insn_t next_insn; */
	/* 	//jit_insn_init(&next_insn, insn->th, insn->cfp, insn->pc + insn->len); */
	/* 	// next_insn.index = trace->insns_iterator; */
	/* 	//dst += next_insn.len; */
	/* 	jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, insn, dst); */
	/* 	bb_dst = dest_insn->bb; */
	/* } */
    /*  */
	/* BasicBlock *bb_else = CreateBasicBlock("branchif"); */
    /*  */
	/* SetBasicBlock(bb_else); */
	/* jit_codegen_make_return(codegen_func); */
	/* SetBasicBlock(insn->bb); */
    /*  */
	/* BUILDER->CreateCondBr(test, bb_dst, bb_else); */

	Value *test = _RTEST(_val);
	JIT_DEBUG_LOG2("branchif: %d, %d, %d", insn->index, insn->len, dst);
	jit_insn_t *next_insn = insns[insn->index + 1];
	jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, next_insn, dst);
	//BasicBlock *bb_dst  = insns[insn->index + insn->len + dst]->bb;
	BasicBlock *bb_dst;
	if (dest_insn) {
		bb_dst = dest_insn->bb;
	}
	else {
		JIT_DEBUG_LOG("dest_insn_else");
		bb_dst = CreateBasicBlock("branchif");
		BUILDER->SetInsertPoint(bb_dst);
		Value* cfp_pc_ptr = BUILDER->CreateStructGEP(_GET_CFP(), 0);
		/* Value* cfp_pc = BUILDER->CreateLoad(cfp_pc_ptr); */
		/* Value* tmp = BUILDER->CreateInBoundsGEP(cfp_pc, RB_JIT->values->value(dst)); */
		/* PRINT_VAL(cfp_pc); */
		/* PRINT_VAL(tmp); */
		/* BUILDER->CreateStore(tmp, cfp_pc_ptr); */
		// jit.cpp:484で強制的にPCを加算しているので、フラグ等で調整したほうがいいかも
		auto last_insn = trace->insns[trace->insns_iterator - 1];
		VALUE *first_pc = trace->insns[0]->pc;
		/* Value *next_cfp_pc = PV(insn->pc + insn->len + dst); */
		Value *next_cfp_pc = PV(insn->pc + insn->len + dst - (last_insn->pc - first_pc + last_insn->len));
		PRINT_VAL(next_cfp_pc);
		BUILDER->CreateStore(next_cfp_pc, cfp_pc_ptr);
		jit_codegen_make_return(codegen_func);
		BUILDER->SetInsertPoint(insn->bb);
	}

	BasicBlock *bb_next = next_insn->bb;
	BUILDER->CreateCondBr(test, bb_dst, bb_next);
}

$branchunless {
// 	Value *test = _RTEST(_val);
// 	JIT_DEBUG_LOG2("branchunless: %d, %d, %d", insn->index, insn->len, dst);
// 	jit_insn_t *next_insn = insns[insn->index + 1];
// 	jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, next_insn, dst);
// 	//BasicBlock *bb_dst  = insns[insn->index + insn->len + dst]->bb;
// 	BasicBlock *bb_dst;
// 	if (dest_insn) {
// 		bb_dst = dest_insn->bb;
// 	}
// 	else {
// 		JIT_DEBUG_LOG("dest_insn_else");
// 		bb_dst = CreateBasicBlock("branchunless");
// 		BUILDER->SetInsertPoint(bb_dst);
// 		Value* cfp_pc = BUILDER->CreateStructGEP(_GET_CFP(), 0);
// 		Value* tmp = BUILDER->CreateInBoundsGEP(cfp_pc, RB_JIT->values->value(dst));
// 		tmp = BUILDER->CreateLoad(tmp);
// 		//Value* tmp2 = BUILDER->CreateAdd(tmp, RB_JIT->values->value(dst));
// 		PRINT_VAL(tmp);
// 		BUILDER->CreateStore(tmp, cfp_pc);
// 		jit_codegen_make_return(codegen_func);
// 		BUILDER->SetInsertPoint(insn->bb);
// 	}
//
// 	BasicBlock *bb_next = next_insn->bb;
// 	BUILDER->CreateCondBr(test, bb_next, bb_dst);

	Value *test = _RTEST(_val);
	JIT_DEBUG_LOG2("branchif: %d, %d, %d", insn->index, insn->len, dst);
	jit_insn_t *next_insn = insns[insn->index + 1];
	jit_insn_t *dest_insn = jit_codegen_jump_insn(trace, next_insn, dst);
	BasicBlock *bb_dst;
	if (dest_insn) {
		bb_dst = dest_insn->bb;
	}
	else {
		JIT_DEBUG_LOG("dest_insn_else");
		bb_dst = CreateBasicBlock("branchif");
		BUILDER->SetInsertPoint(bb_dst);
		Value* cfp_pc_ptr = BUILDER->CreateStructGEP(_GET_CFP(), 0);
		// jit.cpp:484で強制的にPCを加算しているので、フラグ等で調整したほうがいいかも
		auto last_insn = trace->insns[trace->insns_iterator - 1];
		VALUE *first_pc = trace->insns[0]->pc;
		Value *next_cfp_pc = PV(insn->pc + insn->len + dst - (last_insn->pc - first_pc + last_insn->len));
		PRINT_VAL(next_cfp_pc);
		BUILDER->CreateStore(next_cfp_pc, cfp_pc_ptr);
		jit_codegen_make_return(codegen_func);
		BUILDER->SetInsertPoint(insn->bb);
	}

	BasicBlock *bb_next = next_insn->bb;
	BUILDER->CreateCondBr(test, bb_next, bb_dst);
}

// ===============================================
// for optimize
// ===============================================

$getinlinecache {
	// 仮実装
	_val = _Qnil;
}

$setinlinecache {
	// 未実装
}

//$once

//$opt_case_dispatch

// ===============================================
// simple functions
// ===============================================

$opt_plus {
	auto then_fixnum = CreateBasicBlock("then_fixnum");
	auto else_fixnum = CreateBasicBlock("else_fixnum");
	auto merge_fixnum = CreateBasicBlock("merge_fixnum");

	Value* is_fixnum = _FIXNUM_2_P(_recv, _obj);
	BUILDER->CreateCondBr(is_fixnum, then_fixnum, else_fixnum);

	Value* val_fixnum;
	SetBasicBlock(then_fixnum); {
		Value *tmp = BUILDER->CreateAnd(_obj, ~1);
		val_fixnum = BUILDER->CreateAdd(_recv, tmp);
	}
	BUILDER->CreateBr(merge_fixnum);

	Value* val_float;
	SetBasicBlock(else_fixnum); {
		Value* _recv_float = _FCALL1(rb_float_value, _recv);
		Value* _obj_float = _FCALL1(rb_float_value, _obj);
		val_float = BUILDER->CreateFAdd(_recv_float, _obj_float);
		val_float = _FCALL1(rb_float_new_inline, val_float);
	}
	BUILDER->CreateBr(merge_fixnum);

	SetBasicBlock(merge_fixnum);
	PHINode *PN = BUILDER->CreatePHI(jit_types->valueT, 2, "iftmp");

	PN->addIncoming(val_fixnum, then_fixnum);
	PN->addIncoming(val_float, else_fixnum);
	_val = PN;
}

$opt_minus {
	Value *a, *b, *c;

	a = _FIX2LONG(_recv);
	b = _FIX2LONG(_obj);
	c = BUILDER->CreateSub(a, b);
	_val = _LONG2FIX(c);
}

$opt_mult {
	Value *a, *b;

	a = _FIX2LONG(_recv);
	b = _FIX2LONG(_obj);
	_val = _LONG2FIX(BUILDER->CreateMul(a, b));
}

$opt_div {
	Value *x, *y, *div;

	x = _FIX2LONG(_recv);
	y = _FIX2LONG(_obj);
	div = BUILDER->CreateSDiv(x, y);
	_val = _LONG2NUM(div);
}

//$opt_mod

$opt_eq {
    //  val = opt_eq_func(recv, obj, ci);

    //  if (val == Qundef) {
	//  /* other */
	//  PUSH(recv);
	//  PUSH(obj);
	//  CALL_SIMPLE_METHOD(recv);
    //  }

    _val = _FCALL3(opt_eq_func, _recv, _obj, PT(ci, rb_call_info_t));

	BasicBlock *bb_cur = GetBasicBlock();
	           /* *bb_merge = CreateBasicBlock("merge"); */
	SetNewBasicBlock(bb_then, "then_opt_eq");
	_PUSH(_recv);
	_PUSH(_obj);
	_CALL_SIMPLE_METHOD(_recv);
	BasicBlock *bb_merge = GetBasicBlock();
	SetBasicBlock(bb_cur);
	/* _IF_EQ(val, _Qundef, bb_then); */

	Value *test = BUILDER->CreateICmpEQ(_val, _Qundef, "if");
	BUILDER->CreateCondBr(test, bb_then, bb_merge);
	SetBasicBlock(bb_merge);
	/* BasicBlock *bb_merge2 = GetBasicBlock(); */
	/* SetBasicBlock(bb_merge); */
	/* BUILDER->CreateBr(bb_merge2); */
	/* SetBasicBlock(bb_merge2); */
}

//$opt_neq

$opt_lt {
	Value *cmp = BUILDER->CreateICmpSLT(_recv, _obj);
	BasicBlock *bb_then = BasicBlock::Create(CONTEXT, "lt_then", codegen_func.jit_trace_func);
	BasicBlock *bb_else = BasicBlock::Create(CONTEXT, "lt_else", codegen_func.jit_trace_func);
	BasicBlock *bb_merge = BasicBlock::Create(CONTEXT, "lt_merge", codegen_func.jit_trace_func);
	_val = BUILDER->CreateAlloca(RB_JIT->types->valueT);
	BUILDER->CreateCondBr(cmp, bb_then, bb_else);
	BUILDER->SetInsertPoint(bb_then);
	BUILDER->CreateStore(RB_JIT->values->trueV, _val);
	BUILDER->CreateBr(bb_merge);
	BUILDER->SetInsertPoint(bb_else);
	BUILDER->CreateStore(RB_JIT->values->falseV, _val);
	BUILDER->CreateBr(bb_merge);
	BUILDER->SetInsertPoint(bb_merge);
	_val = BUILDER->CreateLoad(_val);
}

//$opt_le

//$opt_gt

//$opt_ge

//$opt_ltlt

$opt_aref {
    /* if (!SPECIAL_CONST_P(recv)) { */
	/* if (RBASIC_CLASS(recv) == rb_cArray && BASIC_OP_UNREDEFINED_P(BOP_AREF, ARRAY_REDEFINED_OP_FLAG) && FIXNUM_P(obj)) { */
	/*     val = rb_ary_entry(recv, FIX2LONG(obj)); */
	/* } */
	/* else if (RBASIC_CLASS(recv) == rb_cHash && BASIC_OP_UNREDEFINED_P(BOP_AREF, HASH_REDEFINED_OP_FLAG)) { */
	/*     val = rb_hash_aref(recv, obj); */
	/* } */
	/* else { */
	/*     goto INSN_LABEL(normal_dispatch); */
	/* } */
    /* } */
    /* else { */
    /*   INSN_LABEL(normal_dispatch): */
	/* PUSH(recv); */
	/* PUSH(obj); */
	/* CALL_SIMPLE_METHOD(recv); */
    /* } */

	Value* rbasic = _RBASIC(_recv);
	Value* klass = _RBASIC_CLASS(rbasic);

	auto bb_array = CreateBasicBlock("then_ary");
	auto bb_else_array = CreateBasicBlock("else_ary");
	auto bb_hash = CreateBasicBlock("then_hash");
	auto bb_merge = CreateBasicBlock("merge");

	Value *test_array = BUILDER->CreateICmpEQ(klass, V(rb_cArray), "if_eq");
	BUILDER->CreateCondBr(test_array, bb_array, bb_else_array);

	SetBasicBlock(bb_else_array); {
		Value *test_hash = BUILDER->CreateICmpEQ(klass, V(rb_cHash), "if_eq");
		BUILDER->CreateCondBr(test_hash, bb_hash, bb_merge);
	}

	Value* val_array;
	SetBasicBlock(bb_array); {
		val_array = _FCALL2(rb_ary_entry, _recv, _FIX2LONG(_obj));
	}
	BUILDER->CreateBr(bb_merge);

	Value* val_hash;
	SetBasicBlock(bb_hash); {
		val_hash = _FCALL2(rb_hash_aref, _recv, _FIX2LONG(_obj));
	}
	BUILDER->CreateBr(bb_merge);

	SetBasicBlock(bb_merge);
	PHINode *PN = BUILDER->CreatePHI(jit_types->valueT, 3, "phi");

	PN->addIncoming(val_array, bb_array);
	PN->addIncoming(val_hash, bb_hash);
	PN->addIncoming(jit_values->valueZero, bb_else_array);
	_val = PN;
}

$opt_aset {
	Value* rbasic = _RBASIC(_recv);
	Value* klass = _RBASIC_CLASS(rbasic);

	auto bb_array = CreateBasicBlock("then_ary");
	auto bb_else_array = CreateBasicBlock("else_ary");
	auto bb_hash = CreateBasicBlock("then_hash");
	auto bb_merge = CreateBasicBlock("merge");

	Value *test_array = BUILDER->CreateICmpEQ(klass, V(rb_cArray), "if_eq");
	BUILDER->CreateCondBr(test_array, bb_array, bb_else_array);

	SetBasicBlock(bb_else_array); {
		Value *test_hash = BUILDER->CreateICmpEQ(klass, V(rb_cHash), "if_eq");
		BUILDER->CreateCondBr(test_hash, bb_hash, bb_merge);
	}

	Value* val_array;
	SetBasicBlock(bb_array); {
		_FCALL3(rb_ary_store, _recv, _FIX2LONG(_obj), _set);
	}
	BUILDER->CreateBr(bb_merge);

	Value* val_hash;
	SetBasicBlock(bb_hash); {
		_FCALL3(rb_hash_aset, _recv, _obj, _set);
	}
	BUILDER->CreateBr(bb_merge);

	SetBasicBlock(bb_merge);

	_val = _set;
	PRINT_VAL(_val);
}

//$opt_aset_with

//$opt_aref_with

//$opt_length

//$opt_size

//$opt_empty_p

//$opt_succ

//$opt_not

//$opt_regexpmatch1

//$opt_regexpmatch2

//$opt_call_c_function

$bitblt {
	_ret = V(rb_str_new2("a bit of bacon, lettuce and tomato"));
}

$answer {
	_ret = V(INT2FIX(42));
}



